// ignore_for_file: avoid_print

import 'dart:io';

import 'package:args/args.dart';
import 'package:dart_apitool/api_tool.dart';
import 'package:dart_apitool/src/package_api_differ.dart';

import 'package_ref.dart';

void main(List<String> arguments) async {
  final listArgParser = ArgParser();
  final dumpArgParser = ArgParser();

  final parser = ArgParser();
  final listCommandParser = parser.addCommand('list', listArgParser);
  listCommandParser.addOption('root',
      abbr: 'r', mandatory: true, help: 'root directory');
  final dumpCommandParser = parser.addCommand('dump', dumpArgParser);
  dumpCommandParser.addOption('root',
      abbr: 'r', mandatory: true, help: 'root directory');

  final cmdHandlerDiff = _addDiffCommand(parser, 'diff');

  final argResults = parser.parse(arguments);
  final cmd = argResults.command;
  if (cmd != null) {
    switch (cmd.name) {
      case 'list':
        await _handleListCommand(cmd);
        break;
      case 'dump':
        await _handleDumpCommand(cmd);
        break;
      case 'diff':
        await cmdHandlerDiff(cmd);
        break;
      default:
    }
  }
}

Future<dynamic> Function(ArgResults) _addDiffCommand(
    ArgParser parser, String commandName) {
  final diffCommandParser = parser.addCommand(commandName);
  final packageRefExplanation = '''
Package reference can be one of:
- directory path pointing to a package on disk (e.g. /path/to/package)
- a diff file generated by dart_apitool (e.g. packageApi.json)
- any package from pub (e.g. pub://package_name/version)
''';
  diffCommandParser.addOption(
    'old',
    mandatory: true,
    help: 'Old package reference. $packageRefExplanation',
  );
  diffCommandParser.addOption(
    'new',
    mandatory: true,
    help: 'New package reference. $packageRefExplanation',
  );
  return (ArgResults cmd) async {
    Future prepare(PackageRef ref) async {
      if (ref.isPackageApiFile || ref.isDirectoryPath) {
        return;
      }
      if (ref.isPubRef) {
        print('Downloading ${ref.pubPackage!}:${ref.pubVersion!}');
        await PubInteraction.installPackageToCache(
            ref.pubPackage!, ref.pubVersion!);
        return;
      }
      throw ArgumentError('Unknown package ref: ${ref.ref}');
    }

    Future<PackageApi> analyze(PackageRef ref) async {
      if (ref.isPackageApiFile) {
        final fileContent = await File(ref.ref).readAsString();
        return PackageApiStorage.packageApiFromStorageJson(fileContent);
      }
      String? path;
      if (ref.isDirectoryPath) {
        path = ref.ref;
      }
      if (ref.isPubRef) {
        path = PubInteraction.getPackagePathInCache(
            ref.pubPackage!, ref.pubVersion!);
      }
      if (path == null) {
        throw ArgumentError('Don\'t know how to handle ${ref.ref}');
      }
      print('Analyzing $path');
      final analyzer = PackageApiAnalyzer(packagePath: path);
      return await analyzer.analyze();
    }

    final oldPackageRef = PackageRef(cmd['old']);
    final newPackageRef = PackageRef(cmd['new']);

    await prepare(oldPackageRef);
    await prepare(newPackageRef);

    final oldPackageApi = await analyze(oldPackageRef);
    final newPackageApi = await analyze(newPackageRef);

    final differ = PackageApiDiffer();
    final diffResult =
        differ.diff(oldApi: oldPackageApi, newApi: newPackageApi);

    // for now just print the diffs
    if (diffResult.apiChanges.isNotEmpty) {
      final breakingChanges =
          diffResult.apiChanges.where((change) => change.type.isBreaking);
      final nonBreakingChanges =
          diffResult.apiChanges.where((change) => !change.type.isBreaking);
      if (breakingChanges.isEmpty) {
        print('No breaking changes!');
      } else {
        print('Breaking changes');
        for (var dr in breakingChanges) {
          print('- ${dr.changeDescription}');
        }
      }
      if (nonBreakingChanges.isEmpty) {
        print('No non-breaking changes');
      } else {
        print('Non-breaking changes');
        for (var dr in nonBreakingChanges) {
          print('- ${dr.changeDescription}');
        }
      }
    } else {
      print('No changes detected!');
    }
  };
}

void _printClasses(List<ClassDeclaration> classDeclarations) {
  print('** Classes:');
  for (final cd in classDeclarations) {
    print('-- ${cd.signature}');
    _printFields(cd.fieldDeclarations, indent: '    ');
    _printExecutables(cd.executableDeclarations, indent: '    ');
  }
}

void _printExecutables(
  List<ExecutableDeclaration> executableDeclarations, {
  String indent = '',
}) {
  print('$indent** Executables:');
  for (final exd in executableDeclarations) {
    print('  $indent${exd.signature}');
  }
}

void _printFields(
  List<FieldDeclaration> fieldDeclarations, {
  String indent = '',
}) {
  print('$indent** Fields:');
  for (final fd in fieldDeclarations) {
    print('  $indent${fd.signature}');
  }
}

Future _handleListCommand(ArgResults cmd) async {
  final String rootDir = cmd['root'];
  final analyzer = PackageApiAnalyzer(packagePath: rootDir);
  final packageApi = await analyzer.analyze();

  print(
      '----- Package ${packageApi.packageName} (${packageApi.packageVersion}) -----');
  _printFields(packageApi.fieldDeclarations);
  _printExecutables(packageApi.executableDeclarations);
  _printClasses(packageApi.classDeclarations);
}

Future _handleDumpCommand(ArgResults cmd) async {
  final String rootDir = cmd['root'];
  final analyzer = PackageApiAnalyzer(packagePath: rootDir);
  final projectApi = await analyzer.analyze();

  final jsonString =
      PackageApiStorage.packageApitoStorageJson(projectApi, pretty: true);
  print(jsonString);
}
