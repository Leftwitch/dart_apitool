// ignore_for_file: avoid_print

import 'dart:io';

import 'package:args/command_runner.dart';
import 'package:dart_apitool/api_tool.dart';
import 'package:dart_apitool/src/package_api_differ.dart';

import 'package_ref.dart';

void main(List<String> arguments) async {
  CommandRunner('dart run dart_apitool', 'A set of utilities for Package APIs')
    ..addCommand(DiffCommand())
    ..run(arguments);
}

class DiffCommand extends Command {
  @override
  final name = "diff";
  @override
  final description = "Creates a diff of 2 given packages.";

  DiffCommand() {
    final packageRefExplanation = '''
Package reference can be one of:
- directory path pointing to a package on disk (e.g. /path/to/package)
- a diff file generated by dart_apitool (e.g. packageApi.json)
- any package from pub (e.g. pub://package_name/version)
''';
    argParser.addOption(
      'old',
      mandatory: true,
      help: 'Old package reference. $packageRefExplanation',
    );
    argParser.addOption(
      'new',
      mandatory: true,
      help: 'New package reference. $packageRefExplanation',
    );
  }

  @override
  Future run() async {
    final oldPackageRef = PackageRef(argResults!['old']);
    final newPackageRef = PackageRef(argResults!['new']);

    await _prepare(oldPackageRef);
    await _prepare(newPackageRef);

    final oldPackageApi = await _analyze(oldPackageRef);
    final newPackageApi = await _analyze(newPackageRef);

    final differ = PackageApiDiffer();
    final diffResult =
        differ.diff(oldApi: oldPackageApi, newApi: newPackageApi);

    // for now just print the diffs
    if (diffResult.apiChanges.isNotEmpty) {
      final breakingChanges =
          diffResult.apiChanges.where((change) => change.type.isBreaking);
      final nonBreakingChanges =
          diffResult.apiChanges.where((change) => !change.type.isBreaking);
      if (breakingChanges.isEmpty) {
        print('No breaking changes!');
      } else {
        print('Breaking changes');
        for (var dr in breakingChanges) {
          print('- ${dr.changeDescription}');
        }
      }
      if (nonBreakingChanges.isEmpty) {
        print('No non-breaking changes');
      } else {
        print('Non-breaking changes');
        for (var dr in nonBreakingChanges) {
          print('- ${dr.changeDescription}');
        }
      }
    } else {
      print('No changes detected!');
    }
  }

  Future _prepare(PackageRef ref) async {
    if (ref.isPackageApiFile || ref.isDirectoryPath) {
      return;
    }
    if (ref.isPubRef) {
      print('Downloading ${ref.pubPackage!}:${ref.pubVersion!}');
      await PubInteraction.installPackageToCache(
          ref.pubPackage!, ref.pubVersion!);
      return;
    }
    throw ArgumentError('Unknown package ref: ${ref.ref}');
  }

  Future<PackageApi> _analyze(PackageRef ref) async {
    if (ref.isPackageApiFile) {
      final fileContent = await File(ref.ref).readAsString();
      return PackageApiStorage.packageApiFromStorageJson(fileContent);
    }
    String? path;
    if (ref.isDirectoryPath) {
      path = ref.ref;
    }
    if (ref.isPubRef) {
      path = PubInteraction.getPackagePathInCache(
          ref.pubPackage!, ref.pubVersion!);
    }
    if (path == null) {
      throw ArgumentError('Don\'t know how to handle ${ref.ref}');
    }
    print('Analyzing $path');
    final analyzer = PackageApiAnalyzer(packagePath: path);
    return await analyzer.analyze();
  }
}
